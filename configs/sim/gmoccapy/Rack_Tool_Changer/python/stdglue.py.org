#!/usr/bin/env python
# -*- coding:UTF-8 -*-

import emccanon 
from interpreter import *
throw_exceptions = 1

from gmoccapy import getiniinfo
import os

CONFIGPATH = os.environ['CONFIG_DIR']

def _get_tool_file_info():
    # first we read the tool file, in case it has been changed
    toolfile = os.path.join(CONFIGPATH, getiniinfo.GetIniInfo().get_toolfile())
    with open(toolfile, "r") as file:
        tool_file_lines = file.readlines()
    file.close()
    
    # now we collect some info about the tool file, to decide if the selected
    # tool is really in the file, if not we abort 
    tool_file_info = {}
    for pos, line in enumerate(tool_file_lines):
        line = line.rstrip('\n')
        toolinfo = line.split(";")
        tool_str = toolinfo[0].split()[0]
        pocket_str = toolinfo[0].split()[1]
        tool_file_info[pocket_str] = tool_str
    return tool_file_info

# REMAP=T   prolog=prepare_prolog ngc=prepare epilog=prepare_epilog
# exposed parameters: #<tool> #<pocket>

def prepare_prolog(self,**words):

    try:
        cblock = self.blocks[self.remap_level]

        # check if an T command has been executed
        if not cblock.t_flag:
            self.set_errormsg("T requires a tool number")
            return INTERP_ERROR

        tool_file_info = _get_tool_file_info()

        # get the tool to be placed in the spindle
        tool  = cblock.t_number
        if tool:
            # as we compare with the tool file, we need to add the T to the string
            toolname = "T{0}".format(tool)
            # if the tool is not in the dict, we get a key error
            try:
                pocketname = tool_file_info.keys()[tool_file_info.values().index(toolname)] 
                pocket = int(pocketname[1:])
            except:
                self.set_errormsg("T{0} is not in tool file!".format(tool))
                return INTERP_ERROR

            # we need to check if the mentioned tool number is not in rack,
            # otherwise we could destroy the tool handling, 
            # due to not unique identification, we have all relevant info 
            # in our dictionary rack_info
            rack_info = {}
            for pos in range(1,11):
                pocket_str = "P{0}".format(pos)
                try:
                    tool_str = tool_file_info[pocket_str]
                except KeyError:
                    tool_str = "0"
                rack_info[pos] = tool_str

            tool_in_rack = False
            for pos in range(1,11):
                if toolname == rack_info[pos]:
                    tool_in_rack = True
                    break
                
            if not tool_in_rack:
                self.set_errormsg("T{0} is not in the changer!".format(tool))
                return INTERP_ERROR

        else:
            pocket = -1 # this is a T0 - tool unload

        self.params["tool"] = tool
        self.params["pocket"] = pocket
        print("Tool {0} is in pocket {1}".format(tool, pocket))
        return INTERP_OK

    except Exception, e:
        self.set_errormsg("T%d/prepare_prolog: %s" % (int(words['t']), e))
        return INTERP_ERROR


def prepare_epilog(self, **words):
    try:
        if not self.value_returned:
            r = self.blocks[self.remap_level].executing_remap
            self.set_errormsg("the %s remap procedure %s did not return a value"
                             % (r.name,r.remap_ngc if r.remap_ngc else r.remap_py))
            return INTERP_ERROR

        if self.blocks[self.remap_level].builtin_used:
            #print "---------- T builtin recursion, nothing to do"
            return INTERP_OK
        else:
            if self.return_value > 0:
                self.selected_tool = int(self.params["tool"])
                self.selected_pocket = int(self.params["pocket"])
                emccanon.SELECT_POCKET(self.selected_pocket, self.selected_tool)
                return INTERP_OK
            else:
                self.set_errormsg("T%d: aborted (return code %.1f)" % (int(self.params["tool"]),self.return_value))
                return INTERP_ERROR
    except Exception, e:
        self.set_errormsg("T%d/prepare_epilog: %s" % (tool,e))
        return INTERP_ERROR       




# REMAP=M6  modalgroup=6 prolog=change_prolog ngc=change epilog=change_epilog
# exposed parameters:
#    #<tool_in_spindle>
#    #<selected_tool>
#    #<current_pocket>
#    #<selected_pocket>

def change_prolog(self, **words):
    try:

        if self.cutter_comp_side:
            self.set_errormsg("Cannot change tools with cutter radius compensation on")
            return INTERP_ERROR

        tool_file_info = _get_tool_file_info()
        
        print("self.current tool says ", self.current_tool)
        print("self.selected tool says ", self.selected_tool)

        toolname = "T{0}".format(self.selected_tool)
        # if the tool is not in the dict, we get a key error
        try:
            pocketname = tool_file_info.keys()[tool_file_info.values().index(toolname)] 
            pocket = int(pocketname[1:])
        except:
            self.set_errormsg("{0} is not in tool file!".format(toolname))
            return INTERP_ERROR

        self.params["tool"] = self.selected_tool
        self.params["pocket"] = self.selected_pocket
        self.params["tool_in_spindle"] = self.current_tool
        self.params["_curr_pocket"] = pocket

        print("tool = ", self.params["tool"] )
        print("pocket = ",self.params["pocket"] )
        print("tool_in_spindle = ",self.params["tool_in_spindle"] )
        print("_curr_pocket = ",self.params["_curr_pocket"] )

        return INTERP_OK

    except Exception, e:
        self.set_errormsg("M6/change_prolog: %s" % (e))
        return INTERP_ERROR


def change_epilog(self, **words):
    print("tool = ", self.params["tool"] )
    print("pocket = ",self.params["pocket"] )
    print("tool_in_spindle = ",self.params["tool_in_spindle"] )
    print("_curr_pocket = ",self.params["_curr_pocket"] )
    try:
        if not self.value_returned:
            r = self.blocks[self.remap_level].executing_remap
            self.set_errormsg("the %s remap procedure %s did not return a value"
                             % (r.name,r.remap_ngc if r.remap_ngc else r.remap_py))
            yield INTERP_ERROR

        if self.blocks[self.remap_level].builtin_used:
            #print "---------- M6 builtin recursion, nothing to do"
            yield INTERP_OK
        else:
            if self.return_value > 0.0:
                # commit change
                emccanon.CHANGE_TOOL(int(self.params["tool"]))
                self.current_pocket = int(self.params["_curr_pocket"])
                self.selected_pocket = -1
                self.selected_tool = -1
                # cause a sync()
                self.set_tool_parameters()
                self.toolchange_flag = True
                yield INTERP_EXECUTE_FINISH
            else:
                self.set_errormsg("M6 aborted (return code %.1f)" % (self.return_value))
                yield INTERP_ERROR
    except Exception, e:
        self.set_errormsg("M6/change_epilog: %s" % (e))
        yield INTERP_ERROR


# this should be called from TOPLEVEL __init__()
def init_stdglue(self):
    self.sticky_params = dict()
